<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>komrade: komrade Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>komrade Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomrade_1_1device__allocator_3_01void_01_4.html">device_allocator&lt; void &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomrade_1_1device__allocator.html">device_allocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomrade_1_1device__new__allocator.html">device_new_allocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1device__reference.html">device_reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomrade_1_1device__vector.html">device_vector</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1unary__function.html">unary_function</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1binary__function.html">binary_function</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1plus.html">plus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1minus.html">minus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1multiplies.html">multiplies</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1divides.html">divides</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1modulus.html">modulus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1negate.html">negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1absolute__value.html">absolute_value</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1equal__to.html">equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1not__equal__to.html">not_equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1greater.html">greater</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1less.html">less</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1greater__equal.html">greater_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1less__equal.html">less_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1logical__and.html">logical_and</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1logical__or.html">logical_or</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1logical__not.html">logical_not</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1identity.html">identity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1maximum.html">maximum</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1minimum.html">minimum</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1unary__negate.html">unary_negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1binary__negate.html">binary_negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkomrade_1_1host__vector.html">host_vector</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1input__device__iterator__tag.html">input_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1output__device__iterator__tag.html">output_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkomrade_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator_traits</b></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomrade_1_1experimental.html">experimental</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekomrade_1_1sorting.html">sorting</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::input_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#g0927e3a6aecf64b535bd28052c7516d5">input_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::output_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#gba20a59557406e3ab657831abf6d65a0">output_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::forward_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#gc0af280b47824bd61134805db6ffe828">forward_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
std::bidirectional_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#gbdabd9cb52934a67a931cfd93d6079f0">bidirectional_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
std::random_access_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#gfde808d31f9339adeda3dcf88077da8d">random_access_host_iterator_tag</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g443af1488089d45b1ea717f203434d88">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g86c34a100eb67397ecdca83959e258e1">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#ge4461604e85da90f1c3fd2f7f1bb952d">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename PredicateIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#gcbf64fac2f186fa88c2dcc12c2974505">copy_if</a> (InputIterator first, InputIterator last, PredicateIterator stencil, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename PredicateIterator, typename OutputIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#g570e5a45d31af7261ef42239fd1fc85b">copy_if</a> (InputIterator begin, InputIterator end, PredicateIterator stencil, OutputIterator result, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator, class EqualityComparable&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">komrade::iterator_traits<br>
&lt; InputIterator &gt;<br>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#g75b2a97fcdcf1766ff9a86b67050036c">count</a> (InputIterator first, InputIterator last, const EqualityComparable &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator, class Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">komrade::iterator_traits<br>
&lt; InputIterator &gt;<br>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#gbe14c51965cd3ef158086aeec9f2cce2">count_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__deallocation__functions.html#g86cf19874997176eff1c45f7fb7f7a6e">device_delete</a> (<a class="el" href="structkomrade_1_1device__ptr.html">komrade::device_ptr</a>&lt; T &gt; ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__deallocation__functions.html#g1e34af40f350d4fd90b469da76012d5e">device_free</a> (<a class="el" href="structkomrade_1_1device__ptr.html">komrade::device_ptr</a>&lt; void &gt; ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structkomrade_1_1device__ptr.html">komrade::device_ptr</a>&lt; void &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#g2344cbff21562ec9a109c7cd44999c90">device_malloc</a> (const std::size_t n)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#g6ba2e5e53b2acf5cdfe8a3818d7ffe42">device_new</a> (<a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; void &gt; p, const size_t n=1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#gd2e4e24feeaefce082c5da55a78aa9ed">device_new</a> (<a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; void &gt; p, const T &amp;exemplar, const size_t n=1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#gc4471b62d4c150154f3b39c6a37c824f">device_new</a> (const size_t n=1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g241691d372cb79de548a89ecdc6e6895">operator==</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g08c62624be436f12d9d83ec632facdde">operator!=</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#gba56260ccd6b500f5f233f6c2c7b032c">operator&lt;</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g6e902e3804ddca236639699ec6e5e9b5">operator&lt;=</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g882131387b9d359d046e3cdada1b5c0d">operator&gt;</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#gc7afe6c0deacacd7e301b00bd47f2097">operator&gt;=</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class E, class T, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; E, T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g104bdeef44f3522682635eb0adcfbf17">operator&lt;&lt;</a> (std::basic_ostream&lt; E, T &gt; &amp;os, const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; Y &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#g8fbaf7ffddae21678ed7afc19ff889c6">device_pointer_cast</a> (T *ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#g085f575a93744d337ec8fa7837e2cad0">device_pointer_cast</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#g7d1643dacb28a3e6ca24f5972ed32dc9">raw_pointer_cast</a> (const <a class="el" href="structkomrade_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#g60fe9f52e0b11c7ed6e59dea37827c06">raw_pointer_cast</a> (T *ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#g2d6624f7698c83af6ffe2241a7e55264">operator==</a> (const <a class="el" href="classkomrade_1_1device__vector.html">device_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classkomrade_1_1device__vector.html">device_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#g3d2797fb1a7a49b1a8d9e6af60358ee7">operator==</a> (const <a class="el" href="classkomrade_1_1host__vector.html">host_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classkomrade_1_1device__vector.html">device_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#g12bf08d6d02c2dccf84083abad0c91e9">operator==</a> (const <a class="el" href="classkomrade_1_1device__vector.html">device_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classkomrade_1_1host__vector.html">host_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#g1207cb42478de9349174478b75a30908">operator==</a> (const std::vector&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classkomrade_1_1device__vector.html">device_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#gd6f31aeff2eb798f13b64327b3f53769">operator==</a> (const <a class="el" href="classkomrade_1_1device__vector.html">device_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const std::vector&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">komrade::iterator_traits<br>
&lt; InputIterator &gt;<br>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#g5332f41a64fb61e7eca2d498210160a0">distance</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparisons.html#g703b0dd762ec8a141d333d5c00c01994">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparisons.html#g35b161a6a0366676f317c32e133eda36">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomrade.html#00a10d45e81d2110b8a79dbfb7ef3e9b">min</a> (const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomrade.html#f1ea438f08e33c64341d42527442379d">min</a> (const T &amp;lhs, const T &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomrade.html#ca9fb8359f803b02e14343667c063aec">max</a> (const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekomrade.html#84619cf210368742728a34991e6c7513">max</a> (const T &amp;lhs, const T &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#g87d457fbc0de23565b01658e48562f57">min_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#gb794a9fa1ecb743ae9d291becf6043b2">min_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#g9af402a1156e97b4de9ead142070177f">max_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#gf9ac60b467d6f4b26f505e13471fed9d">max_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#gbed414aa513391509ba3ac6268951481">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename UnaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelization.html#ged0263346d9d2c419eae264bd617faf9">for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <br>
<a class="el" href="structkomrade_1_1unary__negate.html">unary_negate</a>&lt; Predicate &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__function__object__adaptors.html#ga3fbfed5c41580041c606815acabd5bb">not1</a> (Predicate &amp;pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <br>
<a class="el" href="structkomrade_1_1binary__negate.html">binary_negate</a>&lt; BinaryPredicate &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__function__object__adaptors.html#gffe0523dab03b231e23d40ea703224e0">not2</a> (BinaryPredicate &amp;pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename InputIterator, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g025885122ee5c7bbdd5a4df3ec9f83e3">gather</a> (ForwardIterator first, ForwardIterator last, InputIterator map, RandomAccessIterator input)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename InputIterator1, typename InputIterator2, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g420f2ec7e1038e0c8f40730270b22484">gather_if</a> (ForwardIterator first, ForwardIterator last, InputIterator1 map, InputIterator2 stencil, RandomAccessIterator input)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename InputIterator1, typename InputIterator2, typename RandomAccessIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g89d498b18db012301db2ceb5a81491a4">gather_if</a> (ForwardIterator first, ForwardIterator last, InputIterator1 map, InputIterator2 stencil, RandomAccessIterator input, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Generator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ge13e172ff4448a0f51df4abb896ba200">generate</a> (ForwardIterator first, ForwardIterator last, Generator gen)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__host__containers.html#g3e1729dda9e109032da808c3d43448f2">operator==</a> (const <a class="el" href="classkomrade_1_1host__vector.html">host_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classkomrade_1_1host__vector.html">host_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__host__containers.html#g06af45814f0d7d3111a69b8d5ee14c8b">operator==</a> (const <a class="el" href="classkomrade_1_1host__vector.html">host_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const std::vector&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__host__containers.html#g88e822eb08d685049aa1bccd5f52b38c">operator==</a> (const std::vector&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classkomrade_1_1host__vector.html">host_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename OutputType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#g847b0c1fe0afdbf2ee0d20e834c6ef59">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename OutputType, typename BinaryFunction1, typename BinaryFunction2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#gc4d7dfde21dd6ecc9405a0ccb9b276a5">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#gadc2cd1a777cba4ab4bdf9e1dd383592">is_sorted</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ge7552171029cbb42d2e89f20925f9a6f">is_sorted</a> (ForwardIterator first, ForwardIterator last, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga984147d13d5e3e57f92e3d27552158a">partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename OutputIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g8df24b40acabea0974a67f1ceb12cbf5">partition_copy</a> (ForwardIterator first, ForwardIterator last, OutputIterator result, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g332177172a54c7cf7175b778c36572f3">stable_partition</a> (ForwardIterator begin, ForwardIterator end, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename OutputIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gb9ae4dc32b506b0f343b77eacb0b6657">stable_partition_copy</a> (ForwardIterator begin, ForwardIterator end, OutputIterator result, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g792a805d4a8637a338e3b62e0317d389">range</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#gf6b193caa2c26c181a960260d9f3aabb">range</a> (ForwardIterator first, ForwardIterator last, T init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g51767e0d8f4c61ac729889a1c7d94e87">range</a> (ForwardIterator first, ForwardIterator last, T init, T step)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">komrade::iterator_traits<br>
&lt; InputIterator &gt;::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#g0dcb355a33d9f7ff07c21891fe3a2f89">reduce</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#g8166c6ad9abfabcc689be1e8beaa10a6">reduce</a> (InputIterator first, InputIterator last, T init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename T, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#geb5db80b47ce0079a1b81b2140275c53">reduce</a> (InputIterator first, InputIterator last, T init, BinaryFunction binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga6441a12addd59fb435d475e6be0efb8">remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gc0d46ce96da2df50119e4b6adf3ca5f0">remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g6b987fb3874bacd9d3abc5d3ddbe8eae">remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g1f537611a97a9ab13762f689d3b07c12">remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#gb3c72d3074190dd6c9f2d889e2fca014">replace</a> (ForwardIterator first, ForwardIterator last, const T &amp;old_value, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#g7727f25d9254f7441ee09454301293f2">replace_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#g75a522d17a5239e401b96604aed2df0b">replace_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;old_value, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename Predicate, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#gf22c905b2b1be70c44df2d267ba08fe7">replace_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ge3d7c4e007c70e0cb3d5679602329baa">inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gcaf2fec33562f8d7172fc2fbbfd98ac9">inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g5565c1bab2c57af80a3195a265c29838">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g582814b152e2dd0f08e01926eab420fc">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, const T init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g74ec2bcc18eeee50ae11a296e18d3fda">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, const T init, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g77c29ea82e990103b71d1126030096c3">scatter</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#gf2563c22817a3ed7779872f57c27c87c">scatter_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#gec8ac2ebe1adf87187e47ff99a04c1b0">scatter_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#gbe71e2c3faadf83987bb7937b53d29cf">sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#g61e96f2969a10d2bd220d10fa45ad0ef">sort</a> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#g24bad4a52451d3602c97e3a89f8a3ab8">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#gb18992858cbb72e724db1fc2dbf35ce6">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator1, typename RandomAccessIterator2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#g4765e8da113a34af858a4d5cd02fb4f6">sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessKeyIterator, typename RandomAccessValueIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#gf8bc2496203abf706a77bfdfc31e2f49">sort_by_key</a> (RandomAccessKeyIterator keys_first, RandomAccessKeyIterator keys_last, RandomAccessValueIterator values_first, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessKeyIterator, typename RandomAccessValueIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#g09e75bb6d9fb544dfa88d5cb392ebb3e">stable_sort_by_key</a> (RandomAccessKeyIterator keys_first, RandomAccessKeyIterator keys_last, RandomAccessValueIterator values_first)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessKeyIterator, typename RandomAccessValueIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#gc7cea8abbe437f2d2bba7c12d6301762">stable_sort_by_key</a> (RandomAccessKeyIterator keys_first, RandomAccessKeyIterator keys_last, RandomAccessValueIterator values_first, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator1, typename ForwardIterator2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator2&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#g3bb3e5235be006f7cbf52f9758a78379">swap_ranges</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename UnaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g0e5476c2ab92dbb29d1b7c849bf337af">transform</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g7ca2581bbc99a42f5cad1eb3c2305cfa">transform</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename UnaryFunction, typename OutputType, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#gda4da363057b6e563181ffa3acb4583e">transform_reduce</a> (InputIterator begin, InputIterator end, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename UnaryFunction, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html#g719d7156edb37ed9c1e5caeb1d34b21a">transform_inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename UnaryFunction, typename T, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html#gb9ef0b3bd1bf97ab29e8bfd6c1061a82">transform_exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, T init, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#g33e7b019f9850d0452c0f6946a7a5a66">uninitialized_copy</a> (InputIterator first, InputIterator last, ForwardIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#g14367897eba32be8abeb67d6db327587">uninitialized_fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g2f2c6ff40652385c4dcdd21a33bbe299">unique</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gea295a34e38125a15ce18f4ac052c7c6">unique</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Assignable1, typename Assignable2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#g9b1d6e2dffcef4f1815ff019c7351c20">swap</a> (Assignable1 &amp;a, Assignable2 &amp;b)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
dummy comment here so namespace komrade's documentation will be extracted <hr><h2>Function Documentation</h2>
<a class="anchor" name="84619cf210368742728a34991e6c7513"></a><!-- doxytag: member="komrade::max" ref="84619cf210368742728a34991e6c7513" args="(const T &amp;lhs, const T &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T komrade::max           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000009">Bug:</a></b></dt><dd>The correct form of max does not compile: const T &amp;<a class="el" href="namespacekomrade.html#84619cf210368742728a34991e6c7513">max(const T &amp;lhs, const T &amp;rhs)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca9fb8359f803b02e14343667c063aec"></a><!-- doxytag: member="komrade::max" ref="ca9fb8359f803b02e14343667c063aec" args="(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename BinaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T komrade::max           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000008">Bug:</a></b></dt><dd>The correct form of max does not compile: const T &amp;<a class="el" href="namespacekomrade.html#ca9fb8359f803b02e14343667c063aec">max(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1ea438f08e33c64341d42527442379d"></a><!-- doxytag: member="komrade::min" ref="f1ea438f08e33c64341d42527442379d" args="(const T &amp;lhs, const T &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T komrade::min           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000007">Bug:</a></b></dt><dd>The correct form of min does not compile: const T &amp;<a class="el" href="namespacekomrade.html#f1ea438f08e33c64341d42527442379d">min(const T &amp;lhs, const T &amp;rhs)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="00a10d45e81d2110b8a79dbfb7ef3e9b"></a><!-- doxytag: member="komrade::min" ref="00a10d45e81d2110b8a79dbfb7ef3e9b" args="(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename BinaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T komrade::min           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd>The correct form of min does not compile: const T &amp;<a class="el" href="namespacekomrade.html#00a10d45e81d2110b8a79dbfb7ef3e9b">min(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</a>; </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 5 22:13:58 2009 for komrade by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
