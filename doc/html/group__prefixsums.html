<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>komrade: Prefix Sums</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Prefix Sums<br>
<small>
[<a class="el" href="group__algorithms.html">Algorithms</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html">Transformed Prefix Sums</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ge3d7c4e007c70e0cb3d5679602329baa">komrade::inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gcaf2fec33562f8d7172fc2fbbfd98ac9">komrade::inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g5565c1bab2c57af80a3195a265c29838">komrade::exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g582814b152e2dd0f08e01926eab420fc">komrade::exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, const T init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g74ec2bcc18eeee50ae11a296e18d3fda">komrade::exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, const T init, AssociativeOperator binary_op)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g74ec2bcc18eeee50ae11a296e18d3fda"></a><!-- doxytag: member="komrade::exclusive_scan" ref="g74ec2bcc18eeee50ae11a296e18d3fda" args="(InputIterator first, InputIterator last, OutputIterator result, const T init, AssociativeOperator binary_op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator, typename OutputIterator, typename T, typename AssociativeOperator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void komrade::exclusive_scan           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&nbsp;</td>
          <td class="paramname"> <em>binary_op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>*result</code> and the value <code>binary_op(init, *first)</code> is assigned to <code>*(result + 1)</code>, and so on. This version of the function requires both and associative operator and an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The beginning of the output sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>The initial value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>binary_op</em>&nbsp;</td><td>The associatve operator used to 'sum' values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and <code>OutputIterator's</code> <code>value_type</code> is convertible to both <code>AssociativeOperator's</code> <code>first_argument_type</code> and <code>second_argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AssociativeOperator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>exclusive_scan</code> <p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Defines some functions for computing prefix sums.">komrade/scan.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Defines templated functors and traits analogous to what is found in stl and boost&amp;#39;s...">komrade/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};
 
  <a class="code" href="structkomrade_1_1maximum.html">komrade::maximum&lt;int&gt;</a> binary_op;

  <a class="code" href="group__prefixsums.html#g5565c1bab2c57af80a3195a265c29838">komrade::exclusive_scan</a>(data, data + 10, data, 1, binary_op); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {1, 1, 1, 2, 2, 2, 4, 4, 4, 4 }</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g582814b152e2dd0f08e01926eab420fc"></a><!-- doxytag: member="komrade::exclusive_scan" ref="g582814b152e2dd0f08e01926eab420fc" args="(InputIterator first, InputIterator last, OutputIterator result, const T init)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void komrade::exclusive_scan           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>init</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>init</code> is assigned to <code>*result</code> and the sum of <code>init</code> and <code>*first</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>exclusive_scan</code> assumes <a class="el" href="structkomrade_1_1plus.html">plus</a> as the associative operator but requires an initial value <code>init</code>. When the input and output sequences are the same, the scan is performed in-place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The beginning of the output sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>The initial value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>exclusive_scan</code> <p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Defines some functions for computing prefix sums.">komrade/scan.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[6] = {1, 0, 2, 2, 1, 3};

  <a class="code" href="group__prefixsums.html#g5565c1bab2c57af80a3195a265c29838">komrade::exclusive_scan</a>(data, data + 6, data, 4); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {4, 5, 5, 7, 9, 10}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5565c1bab2c57af80a3195a265c29838"></a><!-- doxytag: member="komrade::exclusive_scan" ref="g5565c1bab2c57af80a3195a265c29838" args="(InputIterator first, InputIterator last, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator, typename OutputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void komrade::exclusive_scan           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>exclusive_scan</code> computes an exclusive prefix sum operation. The term 'exclusive' means that each result does not include the corresponding input operand in the partial sum. More precisely, <code>0</code> is assigned to <code>*result</code> and the sum of <code>0</code> and <code>*first</code> is assigned to <code>*(result + 1)</code>, and so on. This version of <code>exclusive_scan</code> assumes <a class="el" href="structkomrade_1_1plus.html">plus</a> as the associative operator and <code>0</code> as the initial value. When the input and output sequences are the same, the scan is performed in-place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The beginning of the output sequence.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code> <code>value_type</code>, then <code>T(0)</code> is defined.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>exclusive_scan</code> <p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Defines some functions for computing prefix sums.">komrade/scan.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[6] = {1, 0, 2, 2, 1, 3};

  <a class="code" href="group__prefixsums.html#g5565c1bab2c57af80a3195a265c29838">komrade::exclusive_scan</a>(data, data + 6, data); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {0, 1, 1, 3, 5, 6}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gcaf2fec33562f8d7172fc2fbbfd98ac9"></a><!-- doxytag: member="komrade::inclusive_scan" ref="gcaf2fec33562f8d7172fc2fbbfd98ac9" args="(InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator, typename OutputIterator, typename AssociativeOperator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void komrade::inclusive_scan           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssociativeOperator&nbsp;</td>
          <td class="paramname"> <em>binary_op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>inclusive_scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. When the input and output sequences are the same, the scan is performed in-place.<p>
<code>inclusive_scan</code> is similar to <code>std::partial_sum</code> in the STL. The primary difference between the two functions is that <code>std::partial_sum</code> guarantees a serial summation order, while <code>inclusive_scan</code> requires associativity of the binary operation to parallelize the prefix sum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The beginning of the output sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>binary_op</em>&nbsp;</td><td>The associatve operator used to 'sum' values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a> and <code>OutputIterator's</code> <code>value_type</code> is convertible to both <code>AssociativeOperator's</code> <code>first_argument_type</code> and <code>second_argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AssociativeOperator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>AssociativeOperator's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>inclusive_scan</code> <p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};
 
  <a class="code" href="structkomrade_1_1maximum.html">komrade::maximum&lt;int&gt;</a> binary_op;

  <a class="code" href="group__prefixsums.html#ge3d7c4e007c70e0cb3d5679602329baa">komrade::inclusive_scan</a>(data, data + 10, data, 1, binary_op); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {1, 1, 2, 2, 2, 4, 4, 4, 4, 8}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge3d7c4e007c70e0cb3d5679602329baa"></a><!-- doxytag: member="komrade::inclusive_scan" ref="ge3d7c4e007c70e0cb3d5679602329baa" args="(InputIterator first, InputIterator last, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator, typename OutputIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void komrade::inclusive_scan           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>inclusive_scan</code> computes an inclusive prefix sum operation. The term 'inclusive' means that each result includes the corresponding input operand in the partial sum. More precisely, <code>*first</code> is assigned to <code>*result</code> and the sum of <code>*first</code> and <code>*(first + 1)</code> is assigned to <code>*(result + 1)</code>, and so on. This version of inclusive_scan assumes <a class="el" href="structkomrade_1_1plus.html">plus</a> as the associative operator. When the input and output sequences are the same, the scan is performed in-place.<p>
<code>inclusive_scan</code> is similar to <code>std::partial_sum</code> in the STL. The primary difference between the two functions is that <code>std::partial_sum</code> guarantees a serial summation order, while <code>inclusive_scan</code> requires associativity of the binary operation to parallelize the prefix sum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The beginning of the output sequence.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>, and if <code>x</code> and <code>y</code> are objects of <code>OutputIterator's</code> <code>value_type</code>, then <code>x + y</code> is defined. If <code>T</code> is <code>OutputIterator's</code> <code>value_type</code>, then <code>T(0)</code> is defined.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>inclusive_scan</code> <p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="scan_8h.html" title="Defines some functions for computing prefix sums.">komrade/scan.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[6] = {1, 0, 2, 2, 1, 3};

  <a class="code" href="group__prefixsums.html#ge3d7c4e007c70e0cb3d5679602329baa">komrade::inclusive_scan</a>(data, data + 6, data); <span class="comment">// in-place scan</span>

  <span class="comment">// data is now {1, 1, 3, 5, 6, 9}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/partial_sum.html">http://www.sgi.com/tech/stl/partial_sum.html</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Apr 5 22:13:58 2009 for komrade by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
