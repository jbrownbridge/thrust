<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>thrust: thrust::experimental Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacethrust.html">thrust</a>::<a class="el" href="namespacethrust_1_1experimental.html">experimental</a>
  </div>
</div>
<div class="contents">
<h1>thrust::experimental Namespace Reference<br>
<small>
[<a class="el" href="group__transformations.html">Transformations</a>]</small>
</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>constant_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>counting_iterator</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator_adaptor</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>random_access_universal_iterator_tag</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator_core_access</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator_facade</b></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a83b0323ddd6c4d65ca56baf61903bb7"></a><!-- doxytag: member="thrust::experimental::make_constant_iterator" ref="a83b0323ddd6c4d65ca56baf61903bb7" args="(T x, ptrdiff_t c=ptrdiff_t())" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <br>
constant_iterator&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>make_constant_iterator</b> (T x, ptrdiff_t c=ptrdiff_t())</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="216a0e214d0cc7145fe40131ad6b76b3"></a><!-- doxytag: member="thrust::experimental::make_counting_iterator" ref="216a0e214d0cc7145fe40131ad6b76b3" args="(Incrementable x)" -->
template&lt;typename Incrementable, typename Difference&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">counting_iterator<br>
&lt; Incrementable, Difference &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>make_counting_iterator</b> (Incrementable x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="72fc76f17ce98b349d62c2afe4245f65"></a><!-- doxytag: member="thrust::experimental::operator==" ref="72fc76f17ce98b349d62c2afe4245f65" args="(iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)" -->
template&lt;class Dr1, class V1, class TC1, class R1, class P1, class D1, class Dr2, class V2, class TC2, class R2, class P2, class D2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="9f5377a66c92d9085aaad8c2b341ba15"></a><!-- doxytag: member="thrust::experimental::operator!=" ref="9f5377a66c92d9085aaad8c2b341ba15" args="(iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)" -->
template&lt;class Dr1, class V1, class TC1, class R1, class P1, class D1, class Dr2, class V2, class TC2, class R2, class P2, class D2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="851c83717fcace034a648dd951ae15af"></a><!-- doxytag: member="thrust::experimental::operator&lt;" ref="851c83717fcace034a648dd951ae15af" args="(iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)" -->
template&lt;class Dr1, class V1, class TC1, class R1, class P1, class D1, class Dr2, class V2, class TC2, class R2, class P2, class D2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f0bed05ccb8111e31f4f99b6a5d351f4"></a><!-- doxytag: member="thrust::experimental::operator&gt;" ref="f0bed05ccb8111e31f4f99b6a5d351f4" args="(iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)" -->
template&lt;class Dr1, class V1, class TC1, class R1, class P1, class D1, class Dr2, class V2, class TC2, class R2, class P2, class D2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ca60ed26b263f650d9075099ec39eba4"></a><!-- doxytag: member="thrust::experimental::operator&lt;=" ref="ca60ed26b263f650d9075099ec39eba4" args="(iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)" -->
template&lt;class Dr1, class V1, class TC1, class R1, class P1, class D1, class Dr2, class V2, class TC2, class R2, class P2, class D2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="01d4f0db71df1619f000e470c6fda814"></a><!-- doxytag: member="thrust::experimental::operator&gt;=" ref="01d4f0db71df1619f000e470c6fda814" args="(iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)" -->
template&lt;class Dr1, class V1, class TC1, class R1, class P1, class D1, class Dr2, class V2, class TC2, class R2, class P2, class D2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0e8b4e910f7e6a147540e14f2652d513"></a><!-- doxytag: member="thrust::experimental::operator-" ref="0e8b4e910f7e6a147540e14f2652d513" args="(iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)" -->
template&lt;class Dr1, class V1, class TC1, class R1, class P1, class D1, class Dr2, class V2, class TC2, class R2, class P2, class D2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <br>
iterator_facade&lt; Dr1, V1, TC1, <br>
R1, P1, D1 &gt;::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (iterator_facade&lt; Dr1, V1, TC1, R1, P1, D1 &gt; const &amp;lhs, iterator_facade&lt; Dr2, V2, TC2, R2, P2, D2 &gt; const &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ff13967158430aa6e0249b43884eb7c9"></a><!-- doxytag: member="thrust::experimental::operator+" ref="ff13967158430aa6e0249b43884eb7c9" args="(iterator_facade&lt; Derived, V, TC, R, P, D &gt; const &amp;i, typename Derived::difference_type n)" -->
template&lt;class Derived, class V, class TC, class R, class P, class D&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ Derived&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (iterator_facade&lt; Derived, V, TC, R, P, D &gt; const &amp;i, typename Derived::difference_type n)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="be7d8fe166c1ca2517475ad3837d6b23"></a><!-- doxytag: member="thrust::experimental::operator+" ref="be7d8fe166c1ca2517475ad3837d6b23" args="(typename Derived::difference_type n, iterator_facade&lt; Derived, V, TC, R, P, D &gt; const &amp;i)" -->
template&lt;class Derived, class V, class TC, class R, class P, class D&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ Derived&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (typename Derived::difference_type n, iterator_facade&lt; Derived, V, TC, R, P, D &gt; const &amp;i)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1experimental.html#9d4f760eaaaa2b8dcbf2e600e78b1b8f">transform_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename ForwardIterator, typename BinaryFunction, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1experimental.html#4471f30cc58405031c356d88d39e76f7">transform_if</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
// end iterator_tag_classes <hr><h2>Function Documentation</h2>
<a class="anchor" name="4471f30cc58405031c356d88d39e76f7"></a><!-- doxytag: member="thrust::experimental::transform_if" ref="4471f30cc58405031c356d88d39e76f7" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename ForwardIterator, typename BinaryFunction, typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::experimental::transform_if           </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&nbsp;</td>
          <td class="paramname"> <em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&nbsp;</td>
          <td class="paramname"> <em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&nbsp;</td>
          <td class="paramname"> <em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&nbsp;</td>
          <td class="paramname"> <em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunction&nbsp;</td>
          <td class="paramname"> <em>binary_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This version of <code>transform_if</code> conditionally applies a binary function to each pair of elements from two input sequences and stores the result in the corresponding position in an output sequence if the corresponding position in a stencil sequence satifies a predicate. Otherwise, the corresponding position in the output sequence is not modified.<p>
Specifically, for each iterator <code>i</code> in the range <code>[first1, last1)</code> and <code>j = first2 + (i - first1)</code> in the range <code>[first2, first2 + (last1 - first1) )</code>, the predicate <code>pred(*s)</code> is evaluated, where <code>s</code> is the corresponding input iterator in the range <code>[stencil, stencil + (last1 - first1) )</code>. If this predicate evaluates to <code>true</code>, the result of <code>binary_op(*i,*j)</code> is assigned to <code>*o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last1 - first1) )</code>. Otherwise, <code>binary_op(*i,*j)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stencil</em>&nbsp;</td><td>The beginning of the stencil sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The beginning of the output sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>binary_op</em>&nbsp;</td><td>The transformation operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator1</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator1's</code> <code>value_type</code> is convertible to <code>BinaryFunction's</code> <code>first_argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InputIterator2</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>BinaryFunction's</code> <code>second_argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BinaryFunction</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a> and <code>BinaryFunction's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Predicate</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>predicated_transform:</code> <p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="transform_8h.html" title="Defines the interface to a function for transforming an input sequence into an output...">thrust/transform.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Defines templated functors and traits analogous to what is found in stl and boost&amp;#39;s...">thrust/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> input1[6]  = {-5,  0,  2,  3,  2,  4};
  <span class="keywordtype">int</span> input2[6]  = { 3,  6, -2,  1,  2,  3};
  <span class="keywordtype">int</span> stencil[8] = { 1,  0,  1,  0,  1,  0};
  <span class="keywordtype">int</span> output[6];
 
  <a class="code" href="structthrust_1_1plus.html">thrust::plus&lt;int&gt;</a> op;
  <a class="code" href="structthrust_1_1identity.html">thrust::identity&lt;int&gt;</a> identity;

  <a class="code" href="namespacethrust_1_1experimental.html#9d4f760eaaaa2b8dcbf2e600e78b1b8f">thrust::experimental::transform_if</a>(input1, input1 + 6, input2, stencil, output, op, identity);

  <span class="comment">// output is now {-2,  0,  0,  3,  4,  4};</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__transformations.html#g8dfab5757fde90225f5157ded26fc972">thrust::transform</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9d4f760eaaaa2b8dcbf2e600e78b1b8f"></a><!-- doxytag: member="thrust::experimental::transform_if" ref="9d4f760eaaaa2b8dcbf2e600e78b1b8f" args="(InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1, typename InputIterator2, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::experimental::transform_if           </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&nbsp;</td>
          <td class="paramname"> <em>stencil</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This version of <code>transform_if</code> conditionally applies a unary function to each element of an input sequence and stores the result in the corresponding position in an output sequence if the corresponding position in a stencil sequence satifies a predicate. Otherwise, the corresponding position in the output sequence is not modified.<p>
Specifically, for each iterator <code>i</code> in the range <code>[first, last)</code> the predicate <code>pred(*s)</code> is evaluated, where <code>s</code> is the corresponding input iterator in the range <code>[stencil, stencil + (last - first) )</code>. If this predicate evaluates to <code>true</code>, the result of <code>op(*i)</code> is assigned to <code>*o</code>, where <code>o</code> is the corresponding output iterator in the range <code>[result, result + (last - first) )</code>. Otherwise, <code>op(*i)</code> is not evaluated and no assignment occurs. The input and output sequences may coincide, resulting in an in-place transformation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stencil</em>&nbsp;</td><td>The beginning of the stencil sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The beginning of the output sequence. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>The tranformation operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>The predicate operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator1</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator1's</code> <code>value_type</code> is convertible to <code>UnaryFunction's</code> <code>argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InputIterator2</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a> and <code>InputIterator2's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UnaryFunction</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/UnaryFunction.html">Unary Function</a> and <code>UnaryFunction's</code> <code>result_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Predicate</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>transform_if:</code> <p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="transform_8h.html" title="Defines the interface to a function for transforming an input sequence into an output...">thrust/transform.h</a>&gt;</span>
<span class="preprocessor">  #include &lt;<a class="code" href="functional_8h.html" title="Defines templated functors and traits analogous to what is found in stl and boost&amp;#39;s...">thrust/functional.h</a>&gt;</span>
  
  <span class="keywordtype">int</span> data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};
  <span class="keywordtype">int</span> stencil[10] = { 1, 0, 1,  0, 1, 0, 1,  0, 1, 0};
 
  <a class="code" href="structthrust_1_1negate.html">thrust::negate&lt;int&gt;</a> op;
  <a class="code" href="structthrust_1_1identity.html">thrust::identity&lt;int&gt;</a> identity;

  <a class="code" href="namespacethrust_1_1experimental.html#9d4f760eaaaa2b8dcbf2e600e78b1b8f">thrust::experimental::transform_if</a>(data, data + 10, stencil, data, op, identity); <span class="comment">// in-place transformation</span>

  <span class="comment">// data is now {5, 0, -2, -3, -2,  4, 0, -1, -2,  8};</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="group__transformations.html#g8dfab5757fde90225f5157ded26fc972">thrust::transform</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat May 23 22:43:23 2009 for thrust by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
