<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>thrust: Bug List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="bug">Bug List </a></h1><a class="anchor" name="_bug000004"></a> <dl>
<dt>Member <a class="el" href="structthrust_1_1device__reference.html#3f638fcdba9dcc0caeddbb88aca425a4">thrust::device_reference::operator=</a> (const device_reference &amp;ref) </dt>
<dd>This needs to be templated on the type of the <code>device_reference</code> to copy from. </dd>
</dl>
<p>
<a class="anchor" name="_bug000005"></a> <dl>
<dt>Class <a class="el" href="classthrust_1_1device__vector.html">thrust::device_vector&lt; T, Alloc &gt;</a>  </dt>
<dd>The following members do not exist yet: <code>reverse_iterator</code>, <code>const_reverse_iterator</code>, <code>rbegin</code>, <code>rend</code>, <code>pop_back</code>, <code>insert</code>, <code>operator&lt;</code>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_bug000013"></a> <dl>
<dt>Class <a class="el" href="classthrust_1_1host__vector.html">thrust::host_vector&lt; T, Alloc &gt;</a>  </dt>
<dd>The following members do not exist yet: <code>reverse_iterator</code>, <code>const_reverse_iterator</code>, <code>rbegin</code>, <code>rend</code>, <code>pop_back</code>, <code>insert</code>, <code>operator&lt;</code>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_bug000010"></a> <dl>
<dt>Member <a class="el" href="structthrust_1_1identity.html#742669fa03d6e4bb25647b337b342fd7">thrust::identity::operator()</a> (const T &amp;x) const  </dt>
<dd>identity&lt;T&gt;::operator()() should return const T &amp; </dd>
</dl>
<p>
<a class="anchor" name="_bug000011"></a> <dl>
<dt>Member <a class="el" href="structthrust_1_1maximum.html#a74152b956e2ae2d3d824703f834660d">thrust::maximum::operator()</a> (const T &amp;lhs, const T &amp;rhs) const  </dt>
<dd>maximum&lt;T&gt;::operator()() should return const T &amp; </dd>
</dl>
<p>
<a class="anchor" name="_bug000012"></a> <dl>
<dt>Member <a class="el" href="structthrust_1_1minimum.html#65db0d4d8d929247d2ce842797b34ea0">thrust::minimum::operator()</a> (const T &amp;lhs, const T &amp;rhs) const  </dt>
<dd>minimum&lt;T&gt;::operator()() should return const T &amp; </dd>
</dl>
<p>
<a class="anchor" name="_bug000009"></a> <dl>
<dt>Member <a class="el" href="namespacethrust.html#6494be22a814fb21a363e5963df1bbdc">thrust::max</a> (const T &amp;lhs, const T &amp;rhs) </dt>
<dd>The correct form of max does not compile: const T &amp;max(const T &amp;lhs, const T &amp;rhs); </dd>
</dl>
<p>
<a class="anchor" name="_bug000008"></a> <dl>
<dt>Member <a class="el" href="namespacethrust.html#6224f2e380580660689881ce36c942dc">thrust::max</a> (const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp) </dt>
<dd>The correct form of max does not compile: const T &amp;max(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp); </dd>
</dl>
<p>
<a class="anchor" name="_bug000007"></a> <dl>
<dt>Member <a class="el" href="namespacethrust.html#62a2248e1ae6b1c4c7f05fe2110642da">thrust::min</a> (const T &amp;lhs, const T &amp;rhs) </dt>
<dd>The correct form of min does not compile: const T &amp;min(const T &amp;lhs, const T &amp;rhs); </dd>
</dl>
<p>
<a class="anchor" name="_bug000006"></a> <dl>
<dt>Member <a class="el" href="namespacethrust.html#efe61bcc73a9bb0c52e82ae5683450fb">thrust::min</a> (const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp) </dt>
<dd>The correct form of min does not compile: const T &amp;min(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp); </dd>
</dl>
<p>
<a class="anchor" name="_bug000014"></a> <dl>
<dt>Member <a class="el" href="group__regular__copying.html#gb4cbaf418d3e7c83f5f21781ef28b2ef">thrust::uninitialized_copy</a> (InputIterator first, InputIterator last, ForwardIterator result) </dt>
<dd>C++ placement new syntax is required by <code>uninitialized_copy</code>, but placement new is not yet supported in CUDA device functions by the CUDA compiler, <code>nvcc</code>. In the meantime, calls to <code>uninitialized_copy</code> on device memory will be replaced with <code>copy</code>. </dd>
</dl>
<p>
<a class="anchor" name="_bug000001"></a> <dl>
<dt>Member <a class="el" href="group__deallocation__functions.html#g7fa26a9a34d9fd326b31139db16ea997">thrust::device_delete</a> (thrust::device_ptr&lt; T &gt; ptr) </dt>
<dd>The current implementation of <code>device_delete</code> does not invoke <code>T</code>'s destructor on the object <code>*ptr</code>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_bug000003"></a> <dl>
<dt>Member <a class="el" href="group__allocation__functions.html#g0fa58b4eeeb26187d60af1d68bfc2e8e">thrust::device_new</a> (device_ptr&lt; void &gt; p, const T &amp;exemplar, const size_t n=1) </dt>
<dd>Because <code>nvcc</code> cannot yet compile placement <code>new</code> syntax in device code, the behavior of this version of <code>device_new</code> is as if the following is its implementation:<p>
</dd>
</dl>
<p>
<a class="anchor" name="_bug000002"></a> <dl>
<dt>Member <a class="el" href="group__allocation__functions.html#g4c8a057314da6f7dab0b471f5b726247">thrust::device_new</a> (device_ptr&lt; void &gt; p, const size_t n=1) </dt>
<dd>Because <code>nvcc</code> cannot yet compile placement <code>new</code> syntax in device code, this version of <code>device_new</code> invokes <code>T</code>'s null constructor on the host, creates a temporary exemplar, and calls the copy constructor version of <code>device_new</code>.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_bug000015"></a> <dl>
<dt>Member <a class="el" href="group__filling.html#g88a213cd2dd7ceabd528ceb99bbe953b">thrust::uninitialized_fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;x) </dt>
<dd>C++ placement new syntax is required by <code>uninitialized_fill</code>, but placement new is not yet supported in CUDA device functions by the CUDA compiler, <code>nvcc</code>. In the meantime, calls to <code>uninitialized_fill</code> on device memory will be replaced with <code>fill</code>. </dd>
</dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 26 21:09:12 2009 for thrust by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
