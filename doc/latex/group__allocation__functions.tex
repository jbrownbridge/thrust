\section{Allocation Functions}
\label{group__allocation__functions}\index{Allocation Functions@{Allocation Functions}}
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\bf komrade::device\_\-ptr}$<$ void $>$ {\bf komrade::device\_\-malloc} (const std::size\_\-t n)
\item 
{\footnotesize template$<$typename T$>$ }\\device\_\-ptr$<$ T $>$ {\bf komrade::device\_\-new} (device\_\-ptr$<$ void $>$ p, const size\_\-t n=1)
\item 
{\footnotesize template$<$typename T$>$ }\\device\_\-ptr$<$ T $>$ {\bf komrade::device\_\-new} (device\_\-ptr$<$ void $>$ p, const T \&exemplar, const size\_\-t n=1)
\item 
{\footnotesize template$<$typename T$>$ }\\device\_\-ptr$<$ T $>$ {\bf komrade::device\_\-new} (const size\_\-t n=1)
\end{CompactItemize}


\subsection{Function Documentation}
\index{allocation\_\-functions@{allocation\_\-functions}!device\_\-malloc@{device\_\-malloc}}
\index{device\_\-malloc@{device\_\-malloc}!allocation_functions@{allocation\_\-functions}}
\subsubsection[device\_\-malloc]{\setlength{\rightskip}{0pt plus 5cm}{\bf komrade::device\_\-ptr}$<$ T $>$ komrade::device\_\-malloc (const std::size\_\-t {\em n})\hspace{0.3cm}{\tt  [inline]}}\label{group__allocation__functions_g2344cbff21562ec9a109c7cd44999c90}


This version of {\tt device\_\-malloc} allocates sequential device storage for bytes.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]The number of bytes to allocate sequentially in device memory. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} to the newly allocated memory.\end{Desc}
The following code snippet demonstrates how to use {\tt device\_\-malloc} to allocate a range of device memory.



\begin{Code}\begin{verbatim}  #include <komrade/device_malloc.h>
  #include <komrade/device_free.h>
  ...
  // allocate some memory with device_malloc
  const int N = 100;
  komrade::device_ptr<void> void_ptr = komrade::device_malloc(N);

  // manipulate memory
  ...

  // deallocate with device_free
  komrade::device_free(void_ptr);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]\doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr} 

\doxyref{device\_\-free}{p.}{group__deallocation__functions_g1e34af40f350d4fd90b469da76012d5e}\end{Desc}
This version of {\tt device\_\-malloc} allocates sequential device storage for new objects of the given type.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]The number of objects of type T to allocate sequentially in device memory. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} to the newly allocated memory.\end{Desc}
The following code snippet demonstrates how to use {\tt device\_\-malloc} to allocate a range of device memory.



\begin{Code}\begin{verbatim}  #include <komrade/device_malloc.h>
  #include <komrade/device_free.h>
  ...
  // allocate some integers with device_malloc
  const int N = 100;
  komrade::device_ptr<int> int_array = komrade::device_malloc<int>(N);

  // manipulate integers
  ...

  // deallocate with device_free
  komrade::device_free(int_array);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]\doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr} 

\doxyref{device\_\-free}{p.}{group__deallocation__functions_g1e34af40f350d4fd90b469da76012d5e} \end{Desc}
\index{allocation\_\-functions@{allocation\_\-functions}!device\_\-new@{device\_\-new}}
\index{device\_\-new@{device\_\-new}!allocation_functions@{allocation\_\-functions}}
\subsubsection[device\_\-new]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ device\_\-ptr$<$T$>$ komrade::device\_\-new (const size\_\-t {\em n} = {\tt 1})\hspace{0.3cm}{\tt  [inline]}}\label{group__allocation__functions_gc4471b62d4c150154f3b39c6a37c824f}


{\tt device\_\-new} implements the new operator for types resident in device memory. It allocates device memory large enough to hold {\tt n} new objects of type {\tt T}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]The number of objects to allocate. Defaults to {\tt 1}. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} to the newly allocated region of device memory. \end{Desc}
\index{allocation\_\-functions@{allocation\_\-functions}!device\_\-new@{device\_\-new}}
\index{device\_\-new@{device\_\-new}!allocation_functions@{allocation\_\-functions}}
\subsubsection[device\_\-new]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ device\_\-ptr$<$T$>$ komrade::device\_\-new (device\_\-ptr$<$ void $>$ {\em p}, \/  const T \& {\em exemplar}, \/  const size\_\-t {\em n} = {\tt 1})\hspace{0.3cm}{\tt  [inline]}}\label{group__allocation__functions_gd2e4e24feeaefce082c5da55a78aa9ed}


{\tt device\_\-new} implements the placement new operator for types resident in device memory. {\tt device\_\-new} calls {\tt T}'s copy constructor on a array of objects in device memory. No memory is allocated by this function.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p}]A {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} to a region of device memory into which to construct one or many {\tt T}s. \item[{\em exemplar}]The value from which to copy. \item[{\em n}]The number of objects to construct at {\tt p}. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]p, casted to {\tt T}'s type.\end{Desc}
\begin{Desc}
\item[{\bf Bug}]Because {\tt nvcc} cannot yet compile placement {\tt new} syntax in device code, the behavior of this version of {\tt device\_\-new} is as if the following is its implementation:\end{Desc}


\begin{Code}\begin{verbatim}       #include <komrade/fill.h>
       template<typename T> device_ptr<T>
         device_new(device_ptr<void> p,
                    const T &exemplar,
                    const size_t n)
       {
         device_ptr<T> result(reinterpret_cast<T*>(p.get()));
         komrade::fill(result, result + n, exemplar);
         return result;
       }
\end{verbatim}
\end{Code}



Note that this code not invoke {\tt T}'s copy constructor. Rather, it invokes {\tt T}'s assignment operator.

\begin{Desc}
\item[See also:]\doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr} 

\doxyref{fill}{p.}{group__filling_gbed414aa513391509ba3ac6268951481} \end{Desc}
\index{allocation\_\-functions@{allocation\_\-functions}!device\_\-new@{device\_\-new}}
\index{device\_\-new@{device\_\-new}!allocation_functions@{allocation\_\-functions}}
\subsubsection[device\_\-new]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ device\_\-ptr$<$T$>$ komrade::device\_\-new (device\_\-ptr$<$ void $>$ {\em p}, \/  const size\_\-t {\em n} = {\tt 1})\hspace{0.3cm}{\tt  [inline]}}\label{group__allocation__functions_g6ba2e5e53b2acf5cdfe8a3818d7ffe42}


{\tt device\_\-new} implements the placement {\tt new} operator for types resident in device memory. {\tt device\_\-new} calls {\tt T}'s null constructor on a array of objects in device memory. No memory is allocated by this function.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p}]A {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} to a region of device memory into which to construct one or many {\tt T}s. \item[{\em n}]The number of objects to construct at {\tt p}. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]p, casted to {\tt T}'s type.\end{Desc}
\begin{Desc}
\item[{\bf Bug}]Because {\tt nvcc} cannot yet compile placement {\tt new} syntax in device code, this version of {\tt device\_\-new} invokes {\tt T}'s null constructor on the host, creates a temporary exemplar, and calls the copy constructor version of {\tt device\_\-new}.\end{Desc}
\begin{Desc}
\item[See also:]\doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr} \end{Desc}
