\label{bug__bug000004}
 \begin{description}
\item[Member \doxyref{komrade::device\_\-reference::operator=}{p.}{structkomrade_1_1device__reference_d06369f1bf208eaa14a9349ca627c9fb}(const device\_\-reference \&ref) ]This needs to be templated on the type of the {\tt device\_\-reference} to copy from. \end{description}


\label{bug__bug000005}
 \begin{description}
\item[Class \doxyref{komrade::device\_\-vector$<$ T, Alloc $>$}{p.}{classkomrade_1_1device__vector} ]The following members do not exist yet: {\tt reverse\_\-iterator}, {\tt const\_\-reverse\_\-iterator}, {\tt rbegin}, {\tt rend}, {\tt pop\_\-back}, {\tt insert}, {\tt operator$<$}.

\end{description}


\label{bug__bug000013}
 \begin{description}
\item[Class \doxyref{komrade::host\_\-vector$<$ T, Alloc $>$}{p.}{classkomrade_1_1host__vector} ]The following members do not exist yet: {\tt reverse\_\-iterator}, {\tt const\_\-reverse\_\-iterator}, {\tt rbegin}, {\tt rend}, {\tt pop\_\-back}, {\tt insert}, {\tt operator$<$}.

\end{description}


\label{bug__bug000010}
 \begin{description}
\item[Member \doxyref{komrade::identity::operator()}{p.}{structkomrade_1_1identity_4527c0a73f266f53d648bb3de003015c}(const T \&x) const  ]identity$<$T$>$::operator()() should return const T \& \end{description}


\label{bug__bug000011}
 \begin{description}
\item[Member \doxyref{komrade::maximum::operator()}{p.}{structkomrade_1_1maximum_eb1525b1d85bd295a8fba952c32f3233}(const T \&lhs, const T \&rhs) const  ]maximum$<$T$>$::operator()() should return const T \& \end{description}


\label{bug__bug000012}
 \begin{description}
\item[Member \doxyref{komrade::minimum::operator()}{p.}{structkomrade_1_1minimum_49a3e738a2b051dc4fb8da783017c3a2}(const T \&lhs, const T \&rhs) const  ]minimum$<$T$>$::operator()() should return const T \& \end{description}


\label{bug__bug000009}
 \begin{description}
\item[Member \doxyref{komrade::max}{p.}{namespacekomrade_84619cf210368742728a34991e6c7513}(const T \&lhs, const T \&rhs) ]The correct form of max does not compile: const T \&max(const T \&lhs, const T \&rhs); \end{description}


\label{bug__bug000008}
 \begin{description}
\item[Member \doxyref{komrade::max}{p.}{namespacekomrade_ca9fb8359f803b02e14343667c063aec}(const T \&lhs, const T \&rhs, BinaryPredicate comp) ]The correct form of max does not compile: const T \&max(const T \&lhs, const T \&rhs, BinaryPredicate comp); \end{description}


\label{bug__bug000007}
 \begin{description}
\item[Member \doxyref{komrade::min}{p.}{namespacekomrade_f1ea438f08e33c64341d42527442379d}(const T \&lhs, const T \&rhs) ]The correct form of min does not compile: const T \&min(const T \&lhs, const T \&rhs); \end{description}


\label{bug__bug000006}
 \begin{description}
\item[Member \doxyref{komrade::min}{p.}{namespacekomrade_00a10d45e81d2110b8a79dbfb7ef3e9b}(const T \&lhs, const T \&rhs, BinaryPredicate comp) ]The correct form of min does not compile: const T \&min(const T \&lhs, const T \&rhs, BinaryPredicate comp); \end{description}


\label{bug__bug000014}
 \begin{description}
\item[Member \doxyref{komrade::uninitialized\_\-copy}{p.}{group__regular__copying_g33e7b019f9850d0452c0f6946a7a5a66}(InputIterator first, InputIterator last, ForwardIterator result) ]C++ placement new syntax is required by {\tt uninitialized\_\-copy}, but placement new is not yet supported in CUDA device functions by the CUDA compiler, {\tt nvcc}. In the meantime, calls to {\tt uninitialized\_\-copy} on device memory will be replaced with {\tt copy}. \end{description}


\label{bug__bug000001}
 \begin{description}
\item[Member \doxyref{komrade::device\_\-delete}{p.}{group__deallocation__functions_g86cf19874997176eff1c45f7fb7f7a6e}(komrade::device\_\-ptr$<$ T $>$ ptr) ]The current implementation of {\tt device\_\-delete} does not invoke {\tt T}'s destructor on the object {\tt $\ast$ptr}.

\end{description}


\label{bug__bug000003}
 \begin{description}
\item[Member \doxyref{komrade::device\_\-new}{p.}{group__allocation__functions_gd2e4e24feeaefce082c5da55a78aa9ed}(device\_\-ptr$<$ void $>$ p, const T \&exemplar, const size\_\-t n=1) ]Because {\tt nvcc} cannot yet compile placement {\tt new} syntax in device code, the behavior of this version of {\tt device\_\-new} is as if the following is its implementation:

\end{description}


\label{bug__bug000002}
 \begin{description}
\item[Member \doxyref{komrade::device\_\-new}{p.}{group__allocation__functions_g6ba2e5e53b2acf5cdfe8a3818d7ffe42}(device\_\-ptr$<$ void $>$ p, const size\_\-t n=1) ]Because {\tt nvcc} cannot yet compile placement {\tt new} syntax in device code, this version of {\tt device\_\-new} invokes {\tt T}'s null constructor on the host, creates a temporary exemplar, and calls the copy constructor version of {\tt device\_\-new}.

\end{description}


\label{bug__bug000015}
 \begin{description}
\item[Member \doxyref{komrade::uninitialized\_\-fill}{p.}{group__filling_g14367897eba32be8abeb67d6db327587}(ForwardIterator first, ForwardIterator last, const T \&x) ]C++ placement new syntax is required by {\tt uninitialized\_\-fill}, but placement new is not yet supported in CUDA device functions by the CUDA compiler, {\tt nvcc}. In the meantime, calls to {\tt uninitialized\_\-fill} on device memory will be replaced with {\tt fill}. \end{description}
