\section{Regular Copying}
\label{group__regular__copying}\index{Regular Copying@{Regular Copying}}
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\footnotesize template$<$typename InputIterator, typename OutputIterator$>$ }\\OutputIterator {\bf komrade::copy} (InputIterator first, InputIterator last, OutputIterator result)
\item 
{\footnotesize template$<$typename InputIterator, typename PredicateIterator, typename OutputIterator$>$ }\\OutputIterator {\bf komrade::copy\_\-if} (InputIterator first, InputIterator last, PredicateIterator stencil, OutputIterator result)
\item 
{\footnotesize template$<$typename InputIterator, typename PredicateIterator, typename OutputIterator, typename Predicate$>$ }\\OutputIterator {\bf komrade::copy\_\-if} (InputIterator begin, InputIterator end, PredicateIterator stencil, OutputIterator result, Predicate pred)
\item 
{\footnotesize template$<$typename ForwardIterator1, typename ForwardIterator2$>$ }\\ForwardIterator2 {\bf komrade::swap\_\-ranges} (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2)
\item 
{\footnotesize template$<$typename InputIterator, typename ForwardIterator$>$ }\\ForwardIterator {\bf komrade::uninitialized\_\-copy} (InputIterator first, InputIterator last, ForwardIterator result)
\end{CompactItemize}


\subsection{Function Documentation}
\index{regular\_\-copying@{regular\_\-copying}!copy@{copy}}
\index{copy@{copy}!regular_copying@{regular\_\-copying}}
\subsubsection[copy]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename OutputIterator$>$ OutputIterator komrade::copy (InputIterator {\em first}, \/  InputIterator {\em last}, \/  OutputIterator {\em result})\hspace{0.3cm}{\tt  [inline]}}\label{group__regular__copying_ge4461604e85da90f1c3fd2f7f1bb952d}


{\tt copy} copies elements from the range [{\tt first}, {\tt last}) to the range [{\tt result}, {\tt result} + ({\tt last} - {\tt first})). That is, it performs the assignments $\ast${\tt result} = $\ast${\tt first}, $\ast$({\tt result} + {\tt 1}) = $\ast$({\tt first} + {\tt 1}), and so on. Generally, for every integer {\tt n} from {\tt 0} to {\tt last} - {\tt first}, {\tt copy} performs the assignment $\ast$({\tt result} + {\tt n}) = $\ast$({\tt first} + {\tt n}). Unlike {\tt std::copy}, {\tt copy} offers no guarantee on order of operation.

The return value is {\tt result} + ({\tt last} - {\tt first}).

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The beginning of the sequence to copy. \item[{\em last}]The end of the sequence to copy. \item[{\em result}]The destination sequence. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The end of the destination sequence. \end{Desc}
\begin{Desc}
\item[See also:]{\tt http://www.sgi.com/tech/stl/copy.html}\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]must be a model of {\tt Input Iterator} and {\tt InputIterator's} {\tt value\_\-type} must be convertible to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em OutputIterator}]must be a model of {\tt Output Iterator}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt copy} to copy from one range to another.



\begin{Code}\begin{verbatim}  #include <komrade/copy.h>
  #include <komrade/device_vector.h>
  ...

  komrade::device_vector<int> vec0(100);
  komrade::device_vector<int> vec1(100);
  ...

  komrade::copy(vec0.begin(), vec0.end(),
                vec1.begin());

  // vec1 now contains the contents of vec0
\end{verbatim}
\end{Code}

 

Referenced by komrade::device\_\-ptr$<$ T $>$::operator++(), and komrade::device\_\-ptr$<$ T $>$::operator--().\index{regular\_\-copying@{regular\_\-copying}!copy\_\-if@{copy\_\-if}}
\index{copy\_\-if@{copy\_\-if}!regular_copying@{regular\_\-copying}}
\subsubsection[copy\_\-if]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename PredicateIterator, typename OutputIterator, typename Predicate$>$ OutputIterator komrade::copy\_\-if (InputIterator {\em begin}, \/  InputIterator {\em end}, \/  PredicateIterator {\em stencil}, \/  OutputIterator {\em result}, \/  Predicate {\em pred})\hspace{0.3cm}{\tt  [inline]}}\label{group__regular__copying_g570e5a45d31af7261ef42239fd1fc85b}


{\tt copy\_\-if} conditionally copies elements from the range [{\tt first}, {\tt last}) to the range [{\tt result}, {\tt result} + ({\tt last} - {\tt first})). For each iterator {\tt i} in [{\tt first}, {\tt last}) such that {\tt pred}($\ast$({\tt stencil} + ({\tt i} - {\tt last}))) is {\tt true}, the value $\ast${\tt i} is assigned to $\ast$({\tt result} + {\tt i}). Otherwise, $\ast$({\tt result} + {\tt i}) is left unchanged.

The return value is {\tt result} + ({\tt last} - {\tt first}).

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em begin}]The beginning of the sequence to copy. \item[{\em end}]The end of the sequence to copy. \item[{\em stencil}]Predicate iterator controlling the copy. \item[{\em result}]The destination sequence. \item[{\em pred}]Predicate used on stencil values. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The end of the destination sequence.\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]must be a model of {\tt Input Iterator} and {\tt InputIterator's} {\tt value\_\-type} must be convertible to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em PredicateIterator}]must be a model of {\tt Input Iterator} and {\tt PredicateIterator's} {\tt value\_\-type} must be convertible to {\tt Predicate's} {\tt argument\_\-type}. \item[{\em OutputIterator}]must be a model of {\tt Output Iterator}. \item[{\em Predicate}]must be a model of {\tt Predicate}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt copy\_\-if} to copy odd elements from an input range to an output range.



\begin{Code}\begin{verbatim}  #include <komrade/copy.h>
  #include <komrade/device_vector.h>
  ...
  struct is_odd
  {
    __host__ __device__
    bool operator()(const int &x)
    {
      return x & 1;
    }
  };
  ...
  komrade::device_vector<int> input(10);
  komrade::device_vector<int> output(10);
  ...
  // fill input
  ...
  komrade::copy_if(input.begin(), input.end(),
                   input.begin(),
                   output.begin(),
                   is_odd());
  // odd elements of input have been copied to output
\end{verbatim}
\end{Code}

 \index{regular\_\-copying@{regular\_\-copying}!copy\_\-if@{copy\_\-if}}
\index{copy\_\-if@{copy\_\-if}!regular_copying@{regular\_\-copying}}
\subsubsection[copy\_\-if]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename PredicateIterator, typename OutputIterator$>$ OutputIterator komrade::copy\_\-if (InputIterator {\em first}, \/  InputIterator {\em last}, \/  PredicateIterator {\em stencil}, \/  OutputIterator {\em result})\hspace{0.3cm}{\tt  [inline]}}\label{group__regular__copying_gcbf64fac2f186fa88c2dcc12c2974505}


{\tt copy\_\-if} conditionally copies elements from the range [{\tt first}, {\tt last}) to the range [{\tt result}, {\tt result} + ({\tt last} - {\tt first})). For each iterator {\tt i} in the range [{\tt first}, {\tt last}) such that $\ast$({\tt stencil} + ({\tt i} - {\tt first})) is {\tt true}, the value $\ast${\tt i} is assigned to $\ast$({\tt result} + {\tt i}). Otherwise, $\ast$({\tt result} + {\tt i}) is left unchanged.

The return value is {\tt result} + ({\tt last} - {\tt first}).

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The beginning of the sequence to copy. \item[{\em last}]The end of the sequence to copy. \item[{\em stencil}]Predicate iterator controlling the copy. \item[{\em result}]The destination sequence. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The end of the destination sequence.\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]must be a model of {\tt Input Iterator} and {\tt InputIterator's} {\tt value\_\-type} must be convertible to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em PredicateIterator}]must be a model of {\tt Input Iterator} and {\tt value\_\-type} must be convertible to {\tt bool}. \item[{\em OutputIterator}]must be a model of {\tt Output Iterator}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt copy\_\-if} to copy every other element from an input range to an output range.



\begin{Code}\begin{verbatim}  #include <komrade/copy.h>
  #include <komrade/device_vector.h>
  ...
  int   input[10] = {0, 2, 3, 4, 5, 6, 7, 8, 9};
  int stencil[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1};
  komrade::device_vector<int> output(10,0);
  ...
  komrade::copy_if(input, input + 10,
                   stencil,
                   output.begin());
  // every other element of output is now equal to
  // every other element of input
\end{verbatim}
\end{Code}

 \index{regular\_\-copying@{regular\_\-copying}!swap\_\-ranges@{swap\_\-ranges}}
\index{swap\_\-ranges@{swap\_\-ranges}!regular_copying@{regular\_\-copying}}
\subsubsection[swap\_\-ranges]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename ForwardIterator1, typename ForwardIterator2$>$ ForwardIterator2 komrade::swap\_\-ranges (ForwardIterator1 {\em first1}, \/  ForwardIterator1 {\em last1}, \/  ForwardIterator2 {\em first2})\hspace{0.3cm}{\tt  [inline]}}\label{group__regular__copying_g3bb3e5235be006f7cbf52f9758a78379}


{\tt swap\_\-ranges} swaps each of the elements in the range {\tt [first1, last1)} with the corresponding element in the range {\tt [first2, first2 + (last1 - first1))}. That is, for each integer {\tt n} such that {\tt 0 $<$= n $<$ (last1 - first1)}, it swaps {\tt $\ast$(first1 + n)} and {\tt $\ast$(first2 + n)}. The return value is {\tt first2 + (last1 - first1)}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first1}]The beginning of the first sequence to swap. \item[{\em last1}]One position past the last element of the first sequence to swap. \item[{\em first2}]The beginning of the second sequence to swap. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]An iterator pointing to one position past the last element of the second sequence to swap.\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em ForwardIterator1}]is a model of {\tt Forward Iterator}, and {\tt ForwardIterator1's} {\tt value\_\-type} must be convertible to {\tt ForwardIterator2's} {\tt value\_\-type}. \item[{\em ForwardIterator2}]is a model of {\tt Forward Iterator}, and {\tt ForwardIterator2's} {\tt value\_\-type} must be convertible to {\tt ForwardIterator1's} {\tt value\_\-type}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt swap\_\-ranges} to swap the contents of two {\tt komrade::device\_\-vectors}.



\begin{Code}\begin{verbatim}  #include <komrade/swap_ranges.h>
  #include <komrade/device_vector.h>
  ...
  komrade::device_vector<int> v1(2), v2(2);
  v1[0] = 1;
  v1[1] = 2;
  v2[0] = 3;
  v2[1] = 4;

  komrade::swap_ranges(v1.begin(), v1.end(), v2.begin());

  // v1[0] == 3, v1[1] == 4, v2[0] == 1, v2[1] == 2
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]{\tt http://www.sgi.com/tech/stl/swap\_\-ranges.html} 

{\tt \doxyref{swap}{p.}{group__utility_g9b1d6e2dffcef4f1815ff019c7351c20}} \end{Desc}
\index{regular\_\-copying@{regular\_\-copying}!uninitialized\_\-copy@{uninitialized\_\-copy}}
\index{uninitialized\_\-copy@{uninitialized\_\-copy}!regular_copying@{regular\_\-copying}}
\subsubsection[uninitialized\_\-copy]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename ForwardIterator$>$ ForwardIterator komrade::uninitialized\_\-copy (InputIterator {\em first}, \/  InputIterator {\em last}, \/  ForwardIterator {\em result})\hspace{0.3cm}{\tt  [inline]}}\label{group__regular__copying_g33e7b019f9850d0452c0f6946a7a5a66}


In {\tt \doxyref{komrade}{p.}{namespacekomrade}}, the function {\tt \doxyref{komrade::device\_\-new}{p.}{group__allocation__functions_g6ba2e5e53b2acf5cdfe8a3818d7ffe42}} allocates memory for an object and then creates an object at that location by calling a constructor. Occasionally, however, it is useful to separate those two operations. If each iterator in the range {\tt [result, result + (last - first))} points to uninitialized memory, then {\tt uninitialized\_\-copy} creates a copy of {\tt [first, last)} in that range. That is, for each iterator {\tt i} in the input, {\tt uninitialized\_\-copy} creates a copy of {\tt $\ast$i} in the location pointed to by the corresponding iterator in the output range by {\tt ForwardIterator's} {\tt value\_\-type's} copy constructor with $\ast$i as its argument.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The first element of the input range to copy from. \item[{\em last}]The last element of the input range to copy from. \item[{\em result}]The first element of the output range to copy to. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]An iterator pointing to the last element of the output range.\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]is a model of {\tt Input Iterator}. \item[{\em ForwardIterator}]is a model of {\tt Forward Iterator}, {\tt ForwardIterator} is mutable, and {\tt ForwardIterator's} {\tt value\_\-type} has a constructor that takes a single argument whose type is {\tt InputIterator's} {\tt value\_\-type}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt uninitialized\_\-copy} to initialize a range of uninitialized memory.



\begin{Code}\begin{verbatim}  #include <komrade/uninitialized_copy.h>
  #include <komrade/device_malloc.h>
  #include <komrade/device_vector.h>
  ...
  struct Int
  {
    __host__ __device__
    Int(int x) : val(x) {}
    int val;
  };  
  ...
  const int N = 137;

  Int val(46);
  komrade::device_vector<Int> input(N, val);
  komrade::device_ptr<Int> array = komrade::device_malloc<Int>(N);
  komrade::uninitialized_copy(input.begin(), input.end(), array);

  // Int x = array[i];
  // x.val == 46 for all 0 <= i < N
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]{\tt http://www.sgi.com/tech/stl/uninitialized\_\-copy.html} 

{\tt \doxyref{copy}{p.}{group__regular__copying_ge4461604e85da90f1c3fd2f7f1bb952d}} 

{\tt \doxyref{uninitialized\_\-fill}{p.}{group__filling_g14367897eba32be8abeb67d6db327587}} 

{\tt \doxyref{device\_\-new}{p.}{group__allocation__functions_g6ba2e5e53b2acf5cdfe8a3818d7ffe42}} 

{\tt \doxyref{device\_\-malloc}{p.}{group__allocation__functions_g2344cbff21562ec9a109c7cd44999c90}} \end{Desc}
\begin{Desc}
\item[{\bf Bug}]C++ placement new syntax is required by {\tt uninitialized\_\-copy}, but placement new is not yet supported in CUDA device functions by the CUDA compiler, {\tt nvcc}. In the meantime, calls to {\tt uninitialized\_\-copy} on device memory will be replaced with {\tt copy}. \end{Desc}
