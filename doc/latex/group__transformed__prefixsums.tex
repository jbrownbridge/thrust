\section{Transformed Prefix Sums}
\label{group__transformed__prefixsums}\index{Transformed Prefix Sums@{Transformed Prefix Sums}}
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\footnotesize template$<$typename InputIterator, typename OutputIterator, typename UnaryFunction, typename AssociativeOperator$>$ }\\void {\bf komrade::transform\_\-inclusive\_\-scan} (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary\_\-op, AssociativeOperator binary\_\-op)
\item 
{\footnotesize template$<$typename InputIterator, typename OutputIterator, typename UnaryFunction, typename T, typename AssociativeOperator$>$ }\\void {\bf komrade::transform\_\-exclusive\_\-scan} (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary\_\-op, T init, AssociativeOperator binary\_\-op)
\end{CompactItemize}


\subsection{Function Documentation}
\index{transformed\_\-prefixsums@{transformed\_\-prefixsums}!transform\_\-exclusive\_\-scan@{transform\_\-exclusive\_\-scan}}
\index{transform\_\-exclusive\_\-scan@{transform\_\-exclusive\_\-scan}!transformed_prefixsums@{transformed\_\-prefixsums}}
\subsubsection[transform\_\-exclusive\_\-scan]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename OutputIterator, typename UnaryFunction, typename T, typename AssociativeOperator$>$ void komrade::transform\_\-exclusive\_\-scan (InputIterator {\em first}, \/  InputIterator {\em last}, \/  OutputIterator {\em result}, \/  UnaryFunction {\em unary\_\-op}, \/  T {\em init}, \/  AssociativeOperator {\em binary\_\-op})\hspace{0.3cm}{\tt  [inline]}}\label{group__transformed__prefixsums_gb9ef0b3bd1bf97ab29e8bfd6c1061a82}


{\tt transform\_\-exclusive\_\-scan} fuses the {\tt transform} and {\tt exclusive\_\-scan} operations. {\tt transform\_\-exclusive\_\-scan} is equivalent to performing a tranformation defined by {\tt unary\_\-op} into a temporary sequence and then performing an {\tt exclusive\_\-scan} on the tranformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required. In {\tt transform\_\-exclusive\_\-scan}, {\tt init} is assigned to {\tt $\ast$result} and the result of {\tt binary\_\-op(init, unary\_\-op($\ast$first))} is assigned to {\tt $\ast$(result + 1)}, and so on. The transform scan operation is permitted to be in-place.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The beginning of the input sequence. \item[{\em last}]The end of the input sequence. \item[{\em result}]The beginning of the output sequence. \item[{\em unary\_\-op}]The function used to tranform the input sequence. \item[{\em init}]The initial value of the {\tt exclusive\_\-scan} \item[{\em binary\_\-op}]The associatve operator used to 'sum' transformed values.\end{description}
\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]is a model of {\tt Input Iterator} and {\tt InputIterator's} {\tt value\_\-type} is convertible to {\tt unary\_\-op's} input type. \item[{\em OutputIterator}]is a model of {\tt Output Iterator}. \item[{\em UnaryFunction}]is a model of {\tt Unary Function} and accepts inputs of {\tt InputIterator's} {\tt value\_\-type}. {\tt UnaryFunction's} result\_\-type is convertable to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em T}]is convertible to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em AssociativeOperator}]is a model of {\tt Binary Function} and {\tt AssociativeOperator's} {\tt result\_\-type} is convertible to {\tt OutputIterator's} {\tt value\_\-type}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt transform\_\-exclusive\_\-scan} 



\begin{Code}\begin{verbatim}  #include <komrade/transform_scan.h>
  
  int data[6] = {1, 0, 2, 2, 1, 3};

  komrade::negate<int> unary_op;
  komrade::plus<int> binary_op;

  komrade::transform_exclusive_scan(data, data + 6, data, unary_op, 4, binary_op); // in-place scan

  // data is now {4, 3, 3, 1, -1, -2}
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]{\tt \doxyref{transform}{p.}{group__transformations_g0e5476c2ab92dbb29d1b7c849bf337af}} 

{\tt \doxyref{exclusive\_\-scan}{p.}{group__prefixsums_g5565c1bab2c57af80a3195a265c29838}} \end{Desc}
\index{transformed\_\-prefixsums@{transformed\_\-prefixsums}!transform\_\-inclusive\_\-scan@{transform\_\-inclusive\_\-scan}}
\index{transform\_\-inclusive\_\-scan@{transform\_\-inclusive\_\-scan}!transformed_prefixsums@{transformed\_\-prefixsums}}
\subsubsection[transform\_\-inclusive\_\-scan]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename OutputIterator, typename UnaryFunction, typename AssociativeOperator$>$ void komrade::transform\_\-inclusive\_\-scan (InputIterator {\em first}, \/  InputIterator {\em last}, \/  OutputIterator {\em result}, \/  UnaryFunction {\em unary\_\-op}, \/  AssociativeOperator {\em binary\_\-op})\hspace{0.3cm}{\tt  [inline]}}\label{group__transformed__prefixsums_g719d7156edb37ed9c1e5caeb1d34b21a}


{\tt transform\_\-inclusive\_\-scan} fuses the {\tt transform} and {\tt inclusive\_\-scan} operations. {\tt transform\_\-inclusive\_\-scan} is equivalent to performing a tranformation defined by {\tt unary\_\-op} into a temporary sequence and then performing an {\tt inclusive\_\-scan} on the tranformed sequence. In most cases, fusing these two operations together is more efficient, since fewer memory reads and writes are required. In {\tt transform\_\-inclusive\_\-scan}, {\tt unary\_\-op($\ast$first)} is assigned to {\tt $\ast$result} and the result of {\tt binary\_\-op(unary\_\-op($\ast$first), unary\_\-op($\ast$(first + 1)))} is assigned to {\tt $\ast$(result + 1)}, and so on. The transform scan operation is permitted to be in-place.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The beginning of the input sequence. \item[{\em last}]The end of the input sequence. \item[{\em result}]The beginning of the output sequence. \item[{\em unary\_\-op}]The function used to tranform the input sequence. \item[{\em binary\_\-op}]The associatve operator used to 'sum' transformed values.\end{description}
\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]is a model of {\tt Input Iterator} and {\tt InputIterator's} {\tt value\_\-type} is convertible to {\tt unary\_\-op's} input type. \item[{\em OutputIterator}]is a model of {\tt Output Iterator}. \item[{\em UnaryFunction}]is a model of {\tt Unary Function} and accepts inputs of {\tt InputIterator's} {\tt value\_\-type}. {\tt UnaryFunction's} result\_\-type is convertable to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em AssociativeOperator}]is a model of {\tt Binary Function} and {\tt AssociativeOperator's} {\tt result\_\-type} is convertible to {\tt OutputIterator's} {\tt value\_\-type}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt transform\_\-inclusive\_\-scan} 



\begin{Code}\begin{verbatim}  #include <komrade/transform_scan.h>
  
  int data[6] = {1, 0, 2, 2, 1, 3};

  komrade::negate<int> unary_op;
  komrade::plus<int> binary_op;

  komrade::transform_inclusive_scan(data, data + 6, data, unary_op, binary_op); // in-place scan

  // data is now {-1, -1, -3, -5, -6, -9}
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]{\tt \doxyref{transform}{p.}{group__transformations_g0e5476c2ab92dbb29d1b7c849bf337af}} 

{\tt \doxyref{inclusive\_\-scan}{p.}{group__prefixsums_ge3d7c4e007c70e0cb3d5679602329baa}} \end{Desc}
