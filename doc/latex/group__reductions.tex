\section{Reductions}
\label{group__reductions}\index{Reductions@{Reductions}}
\subsection*{Modules}
\begin{CompactItemize}
\item 
{\bf Counting}
\item 
{\bf Comparisons}
\item 
{\bf Extrema}
\item 
{\bf Transformed Reductions}
\item 
{\bf Predicates}
\end{CompactItemize}
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\footnotesize template$<$typename InputIterator$>$ }\\komrade::iterator\_\-traits$<$ InputIterator $>$::value\_\-type {\bf komrade::reduce} (InputIterator first, InputIterator last)
\item 
{\footnotesize template$<$typename InputIterator, typename T$>$ }\\T {\bf komrade::reduce} (InputIterator first, InputIterator last, T init)
\item 
{\footnotesize template$<$typename InputIterator, typename T, typename BinaryFunction$>$ }\\T {\bf komrade::reduce} (InputIterator first, InputIterator last, T init, BinaryFunction binary\_\-op)
\end{CompactItemize}


\subsection{Function Documentation}
\index{reductions@{reductions}!reduce@{reduce}}
\index{reduce@{reduce}!reductions@{reductions}}
\subsubsection[reduce]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename T, typename BinaryFunction$>$ T komrade::reduce (InputIterator {\em first}, \/  InputIterator {\em last}, \/  T {\em init}, \/  BinaryFunction {\em binary\_\-op})\hspace{0.3cm}{\tt  [inline]}}\label{group__reductions_geb5db80b47ce0079a1b81b2140275c53}


{\tt reduce} is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range {\tt [first, last)}. This version of {\tt reduce} uses {\tt init} as the initial value of the reduction and {\tt binary\_\-op} as the binary function used for summation. {\tt reduce} is similar to the C++ Standard Template Library's {\tt std::accumulate}. The primary difference between the two functions is that {\tt std::accumulate} guarantees the order of summation, while {\tt reduce} requires associativity of {\tt binary\_\-op} to parallelize the reduction. If {\tt binary\_\-op} is not commutative, then komrade::stable\_\-reduce should be used instead.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The beginning of the input sequence. \item[{\em last}]The end of the input sequence. \item[{\em init}]The initial value. \item[{\em binary\_\-op}]The binary function used to 'sum' values. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The result of the reduction.\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]is a model of {\tt Input Iterator} and {\tt InputIterator's} {\tt value\_\-type} is convertible to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em OutputIterator}]is a model of {\tt Output Iterator} and {\tt OutputIterator's} {\tt value\_\-type} is convertible to both {\tt AssociativeOperator's} {\tt first\_\-argument\_\-type} and {\tt second\_\-argument\_\-type}. \item[{\em T}]is convertible to {\tt OutputIterator's} {\tt value\_\-type}. \item[{\em AssociativeOperator}]is a model of {\tt Binary Function} and {\tt AssociativeOperator's} {\tt result\_\-type} is convertible to {\tt OutputIterator's} {\tt value\_\-type}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt reduce} to compute the \doxyref{maximum}{p.}{structkomrade_1_1maximum} value of a sequence of integers.



\begin{Code}\begin{verbatim}  #include <komrade/scan.h>
  #include <komrade/functional.h>
  ...
  int data[6] = {1, 0, 2, 2, 1, 3};
  int result = komrade::reduce(data, data + 6, -1,
                               komrade::maximum<int>());
  // result == 3
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]{\tt http://www.sgi.com/tech/stl/accumulate.html} \end{Desc}
\index{reductions@{reductions}!reduce@{reduce}}
\index{reduce@{reduce}!reductions@{reductions}}
\subsubsection[reduce]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator, typename T$>$ T komrade::reduce (InputIterator {\em first}, \/  InputIterator {\em last}, \/  T {\em init})\hspace{0.3cm}{\tt  [inline]}}\label{group__reductions_g8166c6ad9abfabcc689be1e8beaa10a6}


{\tt reduce} is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range {\tt [first, last)}. This version of {\tt reduce} uses {\tt init} as the initial value of the reduction. {\tt reduce} is similar to the C++ Standard Template Library's {\tt std::accumulate}. The primary difference between the two functions is that {\tt std::accumulate} guarantees the order of summation, while {\tt reduce} requires associativity of the binary operation to parallelize the reduction. If the sum operation is not commutative, then komrade::stable\_\-reduce should be used instead.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The beginning of the input sequence. \item[{\em last}]The end of the input sequence. \item[{\em init}]The initial value. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The result of the reduction.\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]is a model of {\tt Input Iterator} and if {\tt x} and {\tt y} are objects of {\tt InputIterator's} {\tt value\_\-type}, then {\tt x + y} is defined and is convertible to {\tt T}. \item[{\em T}]is convertible to {\tt InputIterator's} {\tt value\_\-type}.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt reduce} to compute the sum of a sequence of integers including an intialization value.



\begin{Code}\begin{verbatim}  #include <komrade/scan.h>
  ...
  int data[6] = {1, 0, 2, 2, 1, 3};
  int result = komrade::reduce(data, data + 6, 1);

  // result == 10
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]{\tt http://www.sgi.com/tech/stl/accumulate.html} \end{Desc}
\index{reductions@{reductions}!reduce@{reduce}}
\index{reduce@{reduce}!reductions@{reductions}}
\subsubsection[reduce]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename InputIterator$>$ komrade::iterator\_\-traits$<$InputIterator$>$::value\_\-type komrade::reduce (InputIterator {\em first}, \/  InputIterator {\em last})\hspace{0.3cm}{\tt  [inline]}}\label{group__reductions_g0dcb355a33d9f7ff07c21891fe3a2f89}


{\tt reduce} is a generalization of summation: it computes the sum (or some other binary operation) of all the elements in the range {\tt [first, last)}. This version of {\tt reduce} uses {\tt 0} as the initial value of the reduction. {\tt reduce} is similar to the C++ Standard Template Library's {\tt std::accumulate}. The primary difference between the two functions is that {\tt std::accumulate} guarantees the order of summation, while {\tt reduce} requires associativity of the binary operation to parallelize the reduction. If the sum operation is not commutative, then komrade::stable\_\-reduce should be used instead.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em first}]The beginning of the sequence. \item[{\em last}]The end of the sequence. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The result of the reduction.\end{Desc}
\begin{Desc}
\item[Template Parameters:]
\begin{description}
\item[{\em InputIterator}]is a model of {\tt Input Iterator} and if {\tt x} and {\tt y} are objects of {\tt InputIterator's} {\tt value\_\-type}, then {\tt x + y} is defined and is convertible to {\tt InputIterator's} {\tt value\_\-type}. If {\tt T} is {\tt InputIterator's} {\tt value\_\-type}, then {\tt T(0)} is defined.\end{description}
\end{Desc}
The following code snippet demonstrates how to use {\tt reduce} to compute the sum of a sequence of integers.



\begin{Code}\begin{verbatim}  #include <komrade/reduce.h>
  ...
  int data[6] = {1, 0, 2, 2, 1, 3};
  int result = komrade::reduce(data, data + 6);

  // result == 9
\end{verbatim}
\end{Code}



\begin{Desc}
\item[See also:]{\tt http://www.sgi.com/tech/stl/accumulate.html} \end{Desc}
