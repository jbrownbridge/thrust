\section{komrade::device\_\-reference$<$ T $>$ Struct Template Reference}
\label{structkomrade_1_1device__reference}\index{komrade::device\_\-reference@{komrade::device\_\-reference}}
{\tt \#include $<$device\_\-reference.h$>$}

\subsection*{Public Types}
\begin{CompactItemize}
\item 
typedef {\bf device\_\-ptr}$<$ T $>$ \textbf{pointer}\label{structkomrade_1_1device__reference_753d18328ace929335e3f268e28b0f30}

\end{CompactItemize}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
{\bf device\_\-reference} (const {\bf device\_\-reference} \&ref)
\item 
{\bf device\_\-reference} (const {\bf pointer} \&ptr)
\item 
{\bf pointer} {\bf operator \&} (void) const 
\item 
{\bf device\_\-reference} \& {\bf operator=} (const T \&v)
\item 
{\bf device\_\-reference} \& {\bf operator=} (const {\bf device\_\-reference} \&ref)
\item 
{\bf device\_\-reference} \& {\bf operator++} (void)
\item 
T {\bf operator++} (int)
\item 
{\bf device\_\-reference} \& {\bf operator+=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator--} (void)
\item 
T {\bf operator--} (int)
\item 
{\bf device\_\-reference} \& {\bf operator-=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator$\ast$=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator/=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator\%=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator$<$$<$=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator$>$$>$=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator \&=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator$|$=} (const T \&rhs)
\item 
{\bf device\_\-reference} \& {\bf operator$^\wedge$=} (const T \&rhs)
\item 
{\bf operator T} (void) const 
\end{CompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename T$>$ struct komrade::device\_\-reference$<$ T $>$}

{\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} acts as a reference to an object stored in device memory. {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} is not intended to be used directly; rather, this type is the result of deferencing a {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}}. Similarly, taking the address of a {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} yields a {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}}.

\begin{Desc}
\item[See also:]\doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr} \end{Desc}


\subsection{Constructor \& Destructor Documentation}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!device\_\-reference@{device\_\-reference}}
\index{device\_\-reference@{device\_\-reference}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[device\_\-reference]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf komrade::device\_\-reference}$<$ T $>$::{\bf device\_\-reference} (const {\bf device\_\-reference}$<$ T $>$ \& {\em ref})}\label{structkomrade_1_1device__reference_73b7480c6d3ddf8dd28c4576d92bd35f}


This copy constructor accepts a const reference to another {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}. After this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} is constructed, it shall refer to the same object as {\tt ref}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em ref}]A {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} to copy from.\end{description}
\end{Desc}
The following code snippet demonstrates the semantics of this copy constructor.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_reference<int> ref = v[0];

  // ref equals the object at v[0]
  assert(ref1 == v[0]);

  // the address of ref equals the address of v[0]
  assert(&ref == &v[0]);

  // modifying v[0] modifies ref
  v[0] = 13;
  assert(ref == 13);
\end{verbatim}
\end{Code}

 \index{komrade::device\_\-reference@{komrade::device\_\-reference}!device\_\-reference@{device\_\-reference}}
\index{device\_\-reference@{device\_\-reference}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[device\_\-reference]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf komrade::device\_\-reference}$<$ T $>$::{\bf device\_\-reference} (const {\bf pointer} \& {\em ptr})\hspace{0.3cm}{\tt  [explicit]}}\label{structkomrade_1_1device__reference_2ffacbf48d87b2463d5a4799827b2296}


This copy constructor initializes this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} to refer to an object pointed to by the given {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}}. After this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} is constructed, it shall refer to the object pointed to by {\tt ptr}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em ptr}]A {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} to copy from.\end{description}
\end{Desc}
The following code snippet demonstrates the semantic of this copy constructor.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals the object pointed to by ptr
  assert(ref == *ptr);

  // the address of ref equals ptr
  assert(&ref == ptr);

  // modifying *ptr modifies ref
  *ptr = 13;
  assert(ref == 13);
\end{verbatim}
\end{Code}

 

\subsection{Member Function Documentation}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator \&@{operator \&}}
\index{operator \&@{operator \&}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator \&]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf pointer} {\bf komrade::device\_\-reference}$<$ T $>$::operator \& (void) const}\label{structkomrade_1_1device__reference_cf7c290d0f6e136fb3874eca896ebc6c}


Address-of operator returns a {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} pointing to the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}. It does not return the address of this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Returns:]A {\tt \doxyref{device\_\-ptr}{p.}{structkomrade_1_1device__ptr}} pointing to the object this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} references. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator=@{operator=}}
\index{operator=@{operator=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator= (const T \& {\em v})}\label{structkomrade_1_1device__reference_baca91486692ade95366a10659143c4d}


Assignment operator copies the value of the given object to the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em v}]The value to copy from. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]This {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator=@{operator=}}
\index{operator=@{operator=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator= (const {\bf device\_\-reference}$<$ T $>$ \& {\em ref})}\label{structkomrade_1_1device__reference_d06369f1bf208eaa14a9349ca627c9fb}


Assignment operator copies the value of the object referenced by the given {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} to the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em ref}]The {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} to copy from. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]This {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.\end{Desc}
\begin{Desc}
\item[{\bf Bug}]This needs to be templated on the type of the {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} to copy from. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator++@{operator++}}
\index{operator++@{operator++}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator++]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator++ (void)}\label{structkomrade_1_1device__reference_147d08cc8f0f7cb4cd6f117bbf7a68c6}


Prefix increment operator increments the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Returns:]{\tt $\ast$this}\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} prefix increment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);

  // increment ref
  ++ref;

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The increment executes as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator++@{operator++}}
\index{operator++@{operator++}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator++]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ T {\bf komrade::device\_\-reference}$<$ T $>$::operator++ (int)}\label{structkomrade_1_1device__reference_0ff1874a4e309269be43e28292b0232e}


Postfix increment operator copies the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}, increments the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}, and returns the copy.

\begin{Desc}
\item[Returns:]A copy of the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} before being incremented.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} postfix increment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);

  // increment ref
  int x = ref++;

  // x equals 0
  assert(x == 0)

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The increment executes as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator+=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator+= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_674b87c5778e6a2787915c73d26a382c}


Addition assignment operator add-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the add-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} addition assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);

  // add-assign ref
  ref += 5;

  // ref equals 5
  assert(ref == 5);

  // the object pointed to by ptr equals 5
  assert(*ptr == 5);

  // v[0] equals 5
  assert(v[0] == 5);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The add-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator--@{operator--}}
\index{operator--@{operator--}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator--]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator-- (void)}\label{structkomrade_1_1device__reference_c4136765baf706e20a0651e54b55aa2c}


Prefix decrement operator decrements the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Returns:]{\tt $\ast$this}\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} prefix decrement operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);

  // decrement ref
  --ref;

  // ref equals -1
  assert(ref == -1);

  // the object pointed to by ptr equals -1
  assert(*ptr == -1);

  // v[0] equals -1
  assert(v[0] == -1);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The decrement executes as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator--@{operator--}}
\index{operator--@{operator--}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator--]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ T {\bf komrade::device\_\-reference}$<$ T $>$::operator-- (int)}\label{structkomrade_1_1device__reference_59f56e121329965191ce7af2845398d5}


Postfix decrement operator copies the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}, decrements the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}, and returns the copy.

\begin{Desc}
\item[Returns:]A copy of the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} before being decremented.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} postfix decrement operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);

  // decrement ref
  int x = ref--;

  // x equals 0
  assert(x == 0)

  // ref equals -1
  assert(ref == -1);

  // the object pointed to by ptr equals -1
  assert(*ptr == -1);

  // v[0] equals -1
  assert(v[0] == -1);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The decrement executes as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator-=@{operator-=}}
\index{operator-=@{operator-=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator-=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator-= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_566df8124ae7b7981717e428b6f0edac}


Subtraction assignment operator subtract-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the subtraction-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} addition assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);

  // subtract-assign ref
  ref -= 5;

  // ref equals -5
  assert(ref == -5);

  // the object pointed to by ptr equals -5
  assert(*ptr == -5);

  // v[0] equals -5
  assert(v[0] == -5);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The subtract-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator$\ast$=@{operator$\ast$=}}
\index{operator$\ast$=@{operator$\ast$=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator$\ast$=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator$\ast$= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_99a3cb30b3fadd3b8e1c5de5cb1f6e6e}


Multiplication assignment operator multiply-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the multiply-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} multiply assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,1);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);

  // multiply-assign ref
  ref *= 5;

  // ref equals 5
  assert(ref == 5);

  // the object pointed to by ptr equals 5
  assert(*ptr == 5);

  // v[0] equals 5
  assert(v[0] == 5);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The multiply-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator/=@{operator/=}}
\index{operator/=@{operator/=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator/=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator/= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_60e9916869b637ba00a47f012336ac2e}


Division assignment operator divide-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the divide-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} divide assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,5);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 5
  assert(ref == 5);

  // the object pointed to by ptr equals 5
  assert(*ptr == 5);

  // v[0] equals 5
  assert(v[0] == 5);

  // divide-assign ref
  ref /= 5;

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The divide-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator\%=@{operator\%=}}
\index{operator\%=@{operator\%=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator\%=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator\%= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_0b0204c74cca61dc90d698eb0c62a881}


Modulation assignment operator modulus-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the divide-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} divide assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,5);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 5
  assert(ref == 5);

  // the object pointed to by ptr equals 5
  assert(*ptr == 5);

  // v[0] equals 5
  assert(v[0] == 5);

  // modulus-assign ref
  ref %= 5;

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The modulus-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator$<$$<$=@{operator$<$$<$=}}
\index{operator$<$$<$=@{operator$<$$<$=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator$<$$<$=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator$<$$<$= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_fe8da37546d0023df9dc97e604a480ee}


Bitwise left shift assignment operator left shift-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the left shift-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} left shift assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,1);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);

  // left shift-assign ref
  ref <<= 1;

  // ref equals 2
  assert(ref == 2);

  // the object pointed to by ptr equals 2
  assert(*ptr == 2);

  // v[0] equals 2
  assert(v[0] == 2);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The left shift-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator$>$$>$=@{operator$>$$>$=}}
\index{operator$>$$>$=@{operator$>$$>$=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator$>$$>$=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator$>$$>$= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_67f5c159c698d2b2d232af8f093159df}


Bitwise right shift assignment operator right shift-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the right shift-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} right shift assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,2);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 2
  assert(ref == 2);

  // the object pointed to by ptr equals 2
  assert(*ptr == 2);

  // v[0] equals 2
  assert(v[0] == 2);

  // right shift-assign ref
  ref >>= 1;

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The right shift-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator \&=@{operator \&=}}
\index{operator \&=@{operator \&=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator \&=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator \&= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_09e91457455f78d1d1c4a662ab5df098}


Bitwise AND assignment operator AND-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the AND-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} AND assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,1);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);

  // right AND-assign ref
  ref &= 0;

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The AND-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator\tt{"|}=@{operator\tt{"|}=}}
\index{operator\tt{"|}=@{operator\tt{"|}=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator\tt{"|}=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator$|$= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_2a04507c1d077b9eb3085e907445b9d7}


Bitwise OR assignment operator OR-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the OR-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} OR assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,0);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);

  // right OR-assign ref
  ref |= 1;

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The OR-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator$^\wedge$=@{operator$^\wedge$=}}
\index{operator$^\wedge$=@{operator$^\wedge$=}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator$^\wedge$=]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf device\_\-reference}\& {\bf komrade::device\_\-reference}$<$ T $>$::operator$^\wedge$= (const T \& {\em rhs})}\label{structkomrade_1_1device__reference_9704d7bed35f9c2696612a4a6b254c82}


Bitwise XOR assignment operator XOR-assigns the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} and returns this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em rhs}]The right hand side of the XOR-assignment. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]{\tt $\ast$this}.\end{Desc}
The following code snippet demonstrates the semantics of {\tt device\_\-reference's} XOR assignment operator.



\begin{Code}\begin{verbatim}  #include <komrade/device_vector.h>
  #include <assert.h>
  ...
  komrade::device_vector<int> v(1,1);
  komrade::device_ptr<int> ptr = &v[0];
  komrade::device_reference<int> ref(ptr);

  // ref equals 1
  assert(ref == 1);

  // the object pointed to by ptr equals 1
  assert(*ptr == 1);

  // v[0] equals 1
  assert(v[0] == 1);

  // right XOR-assign ref
  ref ^= 1;

  // ref equals 0
  assert(ref == 0);

  // the object pointed to by ptr equals 0
  assert(*ptr == 0);

  // v[0] equals 0
  assert(v[0] == 0);
\end{verbatim}
\end{Code}



\begin{Desc}
\item[Note:]The XOR-assignment executes as as if it were executed on the host. This may change in a later version. \end{Desc}
\index{komrade::device\_\-reference@{komrade::device\_\-reference}!operator T@{operator T}}
\index{operator T@{operator T}!komrade::device_reference@{komrade::device\_\-reference}}
\subsubsection[operator T]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T$>$ {\bf komrade::device\_\-reference}$<$ T $>$::operator T (void) const}\label{structkomrade_1_1device__reference_a3979824e37b3c81caff19387cf0221f}


Conversion operator converts this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}} to T by returning a copy of the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}.

\begin{Desc}
\item[Returns:]A copy of the object referenced by this {\tt \doxyref{device\_\-reference}{p.}{structkomrade_1_1device__reference}}. \end{Desc}


The documentation for this struct was generated from the following file:\begin{CompactItemize}
\item 
{\bf device\_\-reference.h}\end{CompactItemize}
